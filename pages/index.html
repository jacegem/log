<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Pages | LPP</title>
<meta name=keywords content><meta name=description content="Pages - LPP"><meta name=author content="Jace"><link rel=canonical href=https://blog.moro.kr/pages/><link crossorigin=anonymous href=/assets/css/stylesheet.d6fcd20a4fb86efa4dfac8ec95da60244cc8871042183da1ef28e3a762ad79c8.css integrity="sha256-1vzSCk+4bvpN+sjsldpgJEzIhxBCGD2h7yjjp2Ktecg=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.moro.kr/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.moro.kr/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://blog.moro.kr/favicon.ico><link rel=apple-touch-icon href=https://blog.moro.kr/favicon.ico><link rel=mask-icon href=https://blog.moro.kr/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.moro.kr/pages/index.xml><link rel=alternate type=application/json href=https://blog.moro.kr/pages/index.json><link rel=alternate hreflang=en href=https://blog.moro.kr/pages/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.moro.kr/pages/"><meta property="og:site_name" content="LPP"><meta property="og:title" content="Pages"><meta property="og:locale" content="ko-kr"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pages"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Pages","item":"https://blog.moro.kr/pages/"}]}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-V52SMVT933"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),-gtag("config","G-V52SMVT933")</script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9184373525576918" crossorigin=anonymous></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.moro.kr/ accesskey=h title="Portal (Alt + H)"><img src=https://blog.moro.kr/unicorn72x72.png alt aria-label=logo height=35>Portal</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.moro.kr/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://blog.moro.kr/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://blog.moro.kr/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://blog.moro.kr/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>Pages
<a href=/pages/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Node.js 스트림</h2></header><div class=entry-content><p>Node.js 스트림은 데이터 흐름의 특성과 방향에 따라 네 가지 종류로 분류할 수 있습니다.
읽기 가능 스트림
쓰기 가능 스트림
양방향 스트림
변환 스트림</p></div><footer class=entry-footer><span title='2025-05-19 00:00:00 +0000 UTC'>May 19, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Jace</footer><a class=entry-link aria-label="post link to Node.js 스트림" href=https://blog.moro.kr/pages/node.js-%EC%8A%A4%ED%8A%B8%EB%A6%BC/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>상태 리듀서</h2></header><div class=entry-content><p>useReducer 훅을 사용하는 기본 토글 컴포넌트로 시작하겠습니다.
이 컴포넌트는 토글이 On과 Off 중 어느 위치에 있는지 결정하는 내부 상태를 가집니다.
초기 상태는 false로 설정되어 Off 상태를 나타냅니다.
import React, { useReducer } from 'react' function toggleReducer(state, action) { switch (action.type) { case 'TOGGLE': return { on: !state.on } default: throw new Error(`알 수 없는 액션 타입: ${action.type}`) } } function Toggle() { const [state, dispatch] = useReducer(toggleReducer, {on:false}) return ( &lt;button onClick={()=>dispatch({type:'TOGGLE'})}> {state.on?'On':'Off'} &lt;/button> ) } 상태 리듀서 패턴을 구현하기 위해 Toggle 컴포넌트를 수정해 stateReducer라는 프롭을 받아들이도록 합니다.
이 프롭을 사용하면 컴포넌트의 내부 상태 로직을 변경하거나 확장할 수 있습니다.
...</p></div><footer class=entry-footer><span title='2025-05-19 00:00:00 +0000 UTC'>May 19, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Jace</footer><a class=entry-link aria-label="post link to 상태 리듀서" href=https://blog.moro.kr/pages/%EC%83%81%ED%83%9C-%EB%A6%AC%EB%93%80%EC%84%9C/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>서버 렌더링</h2></header><div class=entry-content><p>서버 렌더링의 장점 최초 의미 있는 페인트(first meaningful paint)가 완성되는 시간이 더 빨리집니다.
서버가 초기 HTML 마크업을 렌더링해 클라이언트로 전송하면 바로 콘텐츠를 볼 수 있기 때문입니다.
애플리케이션이 렌더링되기 전에 클라이언트가 자바스크립트를 다운로드, 파싱, 실행할 때까지 기다려야 하는 클라이언트 사이드 렌더링과 대조적입니다.
웹 애플리케이션의 접근성을 개선합니다.
인터넷 연결 속도가 느리거나 저전력 기기를 사용하는 사용자는 클라이언트 사이드 자바스크립트가 페이지를 로드하고 렌더링할 때까지 기다리는 대신 완전히 렌더링된 HTML을 받기 때문에 사용자 경험이 좋습니다.
...</p></div><footer class=entry-footer><span title='2025-05-19 00:00:00 +0000 UTC'>May 19, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Jace</footer><a class=entry-link aria-label="post link to 서버 렌더링" href=https://blog.moro.kr/pages/%EC%84%9C%EB%B2%84-%EB%A0%8C%EB%8D%94%EB%A7%81/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>고차 컴포넌트 합성</h2></header><div class=entry-content><p>여러 개의 고차 컴포넌트를 하나의 고차 컴포넌트로 합성하는 유틸리티 함수를 작성
const compose = (...hocs) => (WrappedComponent) => hocs.reduceRight((acc,hoc) => hoc(acc), WrappedComponent) // usage const EnhancedComponent = compose(withLogging, withUser)(MyComponent)</p></div><footer class=entry-footer><span title='2025-05-18 00:00:00 +0000 UTC'>May 18, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Jace</footer><a class=entry-link aria-label="post link to 고차 컴포넌트 합성" href=https://blog.moro.kr/pages/%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%95%A9%EC%84%B1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>고차 컴포넌트와 훅의 비교</h2></header><div class=entry-content><p>기능 고차 컴포넌트 훅 코드 재사용 여러 컴포넌트에서 로직을 공유하는데 탁월합니다. 컴포넌트 내 또는 유사한 컴포넌트 간에 로직을 추출하고 공유하는데 이상적입니다. 렌더링 로직 감싸진 컴포넌트의 렌더링을 제어합니다. 렌더링에 직접 영향을 주지는 않지만 함수형 컴포넌트 내에서 렌더링과 관련된 부수적 작용을 관리하는 데 사용합니다. 프롭 조작 프롭을 삽입하고 조작해 추가 데이터나 기능을 제공할 수 있습니다. 프롭을 직접 주입하거나 조작할 수 없습니다. 상태 관리 감싸진 컴포넌트 외부에서 상태를 관리하고 조작합니다. 함수 컴포넌트 내에서 로컬 상태를 관리하도록 설계되었습니다. 수명 주기 방법 감싸진 컴포넌트 관련된 수명 주기 로직을 캡슐화 합니다. useEffect를 비롯한 훅은 함수 컴포넌트 내에서 수명 주기 이벤트를 처리합니다. 합성 용이 합성할 수 있지만 잘 관리하지 않으면 래퍼 지옥이 되기도 합니다. 쉽게 합성할 수 있으며 여러 개의 컴포넌트를 추가하지 않고도 다른 훅과 함께 사용할 수 있습니다. 테스트 용이성 추가 래퍼 컴포넌트로 인해 테스트가 더 복잡해 질 수 있습니다. 일반적으로 고차 컴포넌트보다 쉽게 격리할 수 있으므로 테스트하기가 더 쉽습니다. 타입 안전 타입스크립트를 사용하면 특히 깊게 중첩된 고차 컴포넌트의 경우 올빠르게 입력하기가 까따로울 수 있습니다. 타입스크립트로 타입 추론이 향상되고 입력이 쉬워 집니다.</p></div><footer class=entry-footer><span title='2025-05-18 00:00:00 +0000 UTC'>May 18, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Jace</footer><a class=entry-link aria-label="post link to 고차 컴포넌트와 훅의 비교" href=https://blog.moro.kr/pages/%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%99%80-%ED%9B%85%EC%9D%98-%EB%B9%84%EA%B5%90/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>formState</h2></header><div class=entry-content><p>formState 객체의 주요 멤버 isDirty: 사용자가 어떤 요소를 변경했는지
dirtyFields: 사용자가 변경한 필드 정보 (‘필드명:값’ 형식)
touchedFields: 사용자가 조작한 필드 정보 (‘필드명: true/false’ 형식)
defaultValues: useForm 함수에서 설정된 기본값
isSubmitted: 폼이 제출되었는지 확인
isSubmitSuccessful: 폼이 성공적으로 제출되었는지
isSubmitting: 폼이 제출 중인지
isLoading: 폼이 로딩 중인지 (비동기 기본값을 로드하고 있는지)
submitCount: 폼 제출 횟수
isValid: 폼에 입력한 값이 올바른지
isValidating: 폼이 검증 중인지
errors: 검증 시 발생한 오류 정보</p></div><footer class=entry-footer><span title='2025-05-02 00:00:00 +0000 UTC'>May 2, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Jace</footer><a class=entry-link aria-label="post link to formState" href=https://blog.moro.kr/pages/formstate/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>React hook Form</h2></header><div class=entry-content><p>폼 초기화
const {register, handleSubmit, formState: {error}} = useForm({defaultValues}) useForm 함수의 주요 동작 옵션(인수 opts)
defaultValues
mode
onChange 입력 요소가 변경될 때마다 (성능 저하 가능성 있음)
onBlur 입력 요소에서 초점이 벗어났을 때
onSubmit 제출 시 (이후 onChange, 기본값)
onTouched 첫 번째 onBlur 타이밍 검증 (이후 onChange)
reValidateMode
criterialMode
shouldUseNativeValidation
shouldFocusError
delayError
resolver
useForm 함수의 반환값 (객체의 주요 멤버)
register 폼 요서에 연결해야 하는 이벤트 핸들러 등을 포함한 객체
formState 폼의 상태를 나타내는 객체
watch 지정된 요소 name의 값 가져오기 (변경사항 모니터링)
...</p></div><footer class=entry-footer><span title='2025-05-02 00:00:00 +0000 UTC'>May 2, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Jace</footer><a class=entry-link aria-label="post link to React hook Form" href=https://blog.moro.kr/pages/react-hook-form/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>tsconfig.json</h2></header><div class=entry-content><p>{ "compilerOptions": { "allowJs": true, "checkJs": true, "target": "es5", "lib": ["es2015", "dom", "dom.iterable"], "noImplicitAny": true, "strict": true }, "include": ["./src/**/*"] } compilerOptions: 타입스크립트로 컴파일 할 때 세부적인 동작을 지정할 수 있는 옵션입니다.
allowJs
타입스크립트로 프로젝트를 컴파일 할 때 자바스크립트 파일도 컴파일 대상에 포함시킬지 선택하는 옵션입니다.
checkJs
주로 allowJs 옵션과 같이 사용되며 프로젝트 내 자바스크립트 파일에서 타입스크립트 컴파일 규칙을 적용할지 선택하는 옵션입니다.
target
타입스크립트 코드가 자바스크립트 코드로 컴파일되었을 때 자바스크립트 코드가 실행될 환경을 지정합니다.
예를 들어 마이크로소프트의 인터넷 익스플로러는 ES6+ 이상의 최신 자바스크립트 문법을 지원하지 않으므로 ES5 이하로 지정해 주어야 합니다.
...</p></div><footer class=entry-footer><span title='2025-05-02 00:00:00 +0000 UTC'>May 2, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Jace</footer><a class=entry-link aria-label="post link to tsconfig.json" href=https://blog.moro.kr/pages/tsconfig.json/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>고차 컴포넌트</h2></header><div class=entry-content><p>JSX 세계에서 고차 컴포넌트는 기본적으로 다른 컴포넌트를 인수로 받아 두 컴포넌트의 합성 결과인 새로운 컴포넌트를 반환하는 컴포넌트입니다.
고차 컴포넌트는 여러 컴포넌트에서 공유하는 동작을 반복 작성하고 싶지 않을 때 유용합니다.
외부 데이터 소스와 비동기적으로 통신하는 모든 컴포넌트에 대해 로딩, 오류 및 데이터 패턴을 반복하는 대신 고차 컴포넌트 팩토리를 사용해 이러한 상태를 대신 처리할 수 있습니다.
이 문제를 해결하는 withAsync라는 고차 컴포넌트 팩토리를 생각해 봅시다
const TodoList = withAsync(BasicTodoList) const withAsync = (Component) => (props) => { if (props.loading) { return '로딩 중...' } if (props.error) { return error.message } return ( &lt;Component // `Component`에 전달할 프롭을 모두 그대로 전달 {...props} /> ) } const TodoList = withAsync(BasicTodoList) const App = () => { const [isLoading, setIsLoading] = useState(true) const [data, setData] = useState([]) const [error, setError] = useState([]) useEffect(()=>{ fetch('https://mytodolist.com/items') .then((res)=>res.json()) .then((date)=>{ setIsLoading(false) setData(data) }) .catch(setError) }, []) return &lt;TodoList loading={isLoading} error={error} data={data} /> } 리액트에서 가장 유명한 고차 컴포넌트는 리액트에서 제공하는 API 중 하나인 React.memo 다.
...</p></div><footer class=entry-footer><span title='2025-05-02 00:00:00 +0000 UTC'>May 2, 2025</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Jace</footer><a class=entry-link aria-label="post link to 고차 컴포넌트" href=https://blog.moro.kr/pages/%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>고차 함수를 활용한 리액트 고차 컴포넌트 만들어보기</h2></header><div class=entry-content><p>고차 컴포넌트를 구현하기에 앞서 구현 시 주의할 점을 살펴보자.
사용자 정의 훅이 use 로 시작하는 이름을 사용했다면 리액트의 고차 컴포넌트도 마찬가지로 with 로 시작하는 이름을 사용해야 한다는 것이다.
고차 컴포넌트를 사용할 때 주의할 점 중 하나는 부수 효과를 최소화해야 한다는 것이다.
interface LoginProps { loginRequired?: boolean } function withLoginComponent&lt;T>(Component: ComponentType&lt;T>) { return function (props: T & LoginProps) { const {loginRequired, ...restProps} = props if (loginRequired) { return &lt;>로그인이 필요합니다.&lt;/> } return &lt;Component {...(restProps as T)} /> } } // 원래 구현하고자 하는 컴포넌트를 만들고, withLoginComponent로 감싸기만 하면 끝이다. // 로그인 여부, 로그인이 안 되면 다른 컴포넌트를 렌더링하는 책임은 모두 // 고차 컴포넌트인 withLoginComponent에 맡길 수 있어 매우 편리하다 const Component = withLoginComponent((props: {value:string})=> { return &lt;h3>{props.value}&lt;/h3> }) export default function App() { // 로그인 관련 정보를 가져온다. const isLogin = true return &lt;Component value="text" loginRequired={isLogin} /> }</p></div><footer class=entry-footer><span title='2025-05-02 00:00:00 +0000 UTC'>May 2, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Jace</footer><a class=entry-link aria-label="post link to 고차 함수를 활용한 리액트 고차 컴포넌트 만들어보기" href=https://blog.moro.kr/pages/%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B3%A0%EC%B0%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EA%B8%B0/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://blog.moro.kr/pages/page/2/>Next&nbsp;&nbsp;»</a></nav></footer><code></code><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://blog-moro-kr.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></main><footer class=footer><span>&copy; 2025 <a href=https://blog.moro.kr/>LPP</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>